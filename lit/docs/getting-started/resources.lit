\title{Resources}{tutorial-resources}

\use-plugin{concourse-docs}

\section{
    \title{The Heart of Concourse}

    Resources are the heart of Concourse. Resources make Concourse tick and are
    the source of automation within all Concourse pipelines. Resources are how
    Concourse interacts with the outside world. Here's a short list of some
    things that resources can do:

    \list{
        You want something to run every five minutes? \link{Time resource}{https://github.com/concourse/time-resource/}.
    }{
        You want to run tests on every new commit to the main branch? \link{Git resource}{https://github.com/concourse/git-resource}.
    }{
        Run unit tests on new PR's? \link{Github-PR resource}{https://github.com/telia-oss/github-pr-resource}.
    }{
        Deploy the latest image of your app? \link{Registry-image resource}{https://github.com/concourse/registry-image-resource/}
    }

    Resources can do a lot of things! The main goal of resources is to
    represent some external system or object in your pipeline. That external
    thing can then be used as a trigger for your \reference{jobs} or your
    \reference{jobs} can push back and modify the external system or object. It
    all depends on the resource you use and what features its author has
    implemented.

    Resources are also how Concourse tries to stay as technology agnostic as
    possible. For example, Concourse doesn't care what \link{version control
    system}{https://en.wikipedia.org/wiki/Version_control} you use. If you can
    put your latest and hottest tech behind the resource interface then
    Concourse can use it.

    The Concourse team bundles a few resource types that come with the Linux
    tarball you can \link{download from
    Github}{https://github.com/concourse/concourse/releases}. You'll notice
    that the Linux tarball is much larger than the macOS or Windows tarball
    because of all the bundled resources.

    Resources only run on Linux workers because resources are distributed as
    Linux container images. There are currently no resources for macOS or
    Windows. Only \reference{task-step}{task steps} can run on macOS or Windows
    workers.
}

\section{
    \title{Versions}

    Resources represent the external system or object to Concourse by emitting
    \reference{schema.version}{\code{versions}}. A version is any way that a
    resource can uniquely identify the state of the external system or object.

    For example, for the git resource, each version it emits is represented by
    the SHA of that commit.

    Let's start digging into resources a bit more by going over the technical
    components of a resource.
}

\section{
    \title{Components of Resources}

    Resources are \link{container
    images}{https://en.wikipedia.org/wiki/List_of_Linux_containers} that
    contain three executables. Each executable is run by a different
    \reference{steps}{step} within your pipeline:

    \list{
        \code{/opt/resource/check} - implicitly ran when a
        \reference{jobs}{job} contains a \reference{get-step}{get step}.
        Should return the latest version. It's responsibility is to find new
        versions.
    }{
        \code{/opt/resource/in} - run in a \reference{get-step}{get step}.
        \code{in} is given a specific version (generated by a \code{check} or
        \reference{put-step}{\code{put} step}) and retrieves the files
        representing that version.
    }{
        \code{/opt/resource/out} - run in a \reference{put-step}{put step}.
        Generates a new version, usually based on some input.
    }

    Those are the technical pieces of a resource. Next, we will learn how to
    add them to our pipeline.
}

\section{
    \title{Get Steps}

    Let's add some automation to our \code{hello-world.yml} pipeline and have
    it \bold{trigger every one minute}. We will use the \link{time
    resource}{https://github.com/concourse/time-resource/} to accomplish this.

    First, let's go back to the one step version of the pipeline.

    \codeblock{yaml}{{
    jobs:
    - name: hello-world-job
      plan:
      - task: hello-world-task
        config:
          platform: linux
          image_resource:
            type: registry-image
            source:
              repository: busybox
          run:
            path: echo
            args: ["Hello World!"]
    }}

    Now let's add the \link{time
    resource}{https://github.com/concourse/time-resource/} to the pipeline.
    First we'll add the \reference{resources}{\code{resources}} key to the
    top-level of our yaml.

    \codeblock{yaml}{{
    resources:

    jobs:
    - name: hello-world-job
      plan:
      - task: hello-world-task
        config:
          platform: linux
          image_resource:
            type: registry-image
            source:
              repository: busybox
          run:
            path: echo
            args: ["Hello World!"]
    }}

    The \reference{resources}{\code{resources}} key takes a list of resources.
    In our case, we're going to add one item to that list. We will name the
    resource \code{every-1min}. This is the name we'll use to refer to this
    specific instance of the resource within our pipeline. We'll define the
    \reference{schema.resource.type}{\code{type}} as \code{time}.

    \codeblock{yaml}{{
    resources:
    - name: every-1min
      type: time

    jobs:
    - name: hello-world-job
      plan:
      - task: hello-world-task
        config:
          platform: linux
          image_resource:
            type: registry-image
            source:
              repository: busybox
          run:
            path: echo
            args: ["Hello World!"]
    }}

    There is one last field we need to fill out, the
    \reference{schema.resource.source}{\code{source}} field.

    The \code{source} field contains the configuration for this instance of the
    resource. By convention, documentation for each resource type's
    configuration is found in it's \code{README} of its git repository.

    If we look at the \link{\code{README} for the time
    resource}{https://github.com/concourse/time-resource/#source-configuration}
    we'll find that there is an \code{interval} field where we can specify how
    often the time resource emits a new version. Let's add that and set it to
    \code{1m}.

    \codeblock{yaml}{{
    resources:
    - name: every-1min
      type: time
      source:
        interval: 1m

    jobs:
    - name: hello-world-job
      plan:
      - task: hello-world-task
        config:
          platform: linux
          image_resource:
            type: registry-image
            source:
              repository: busybox
          run:
            path: echo
            args: ["Hello World!"]
    }}

    Next we need to connect the resource to the \code{hello-world-job}. We
    connect the two pieces by adding a \reference{get-step}{get step} to the
    job.

    \codeblock{yaml}{{
    resources:
    - name: every-1min
      type: time
      source:
        interval: 1m

    jobs:
    - name: hello-world-job
      plan:
      # Add a get step referencing the resource
      - get: every-1min
      - task: hello-world-task
        config:
          platform: linux
          image_resource:
            type: registry-image
            source:
              repository: busybox
          run:
            path: echo
            args: ["Hello World!"]
    }}

    The final piece is telling Concourse to trigger the \code{hello-world-job}
    whenever the \code{every-1min} resource emits a new version. We can do that
    by setting \reference{schema.step.get-step.trigger}{\code{trigger}} to
    \code{true} for the \reference{get-step}{get step}.

    \codeblock{yaml}{{
    resources:
    - name: every-1min
      type: time
      source:
        interval: 1m

    jobs:
    - name: hello-world-job
      plan:
      - get: every-1min
        trigger: true   # tell Concourse to trigger when new versions are emitted
      - task: hello-world-task
        config:
          platform: linux
          image_resource:
            type: registry-image
            source:
              repository: busybox
          run:
            path: echo
            args: ["Hello World!"]
    }}

    Let's set our pipeline and watch it automatically trigger from the
    \link{web UI}{http://localhost:8080/teams/main/pipelines/hello-world}.

    \codeblock{}{{
    $ fly -t tutorial set-pipeline -p hello-world -c hello-world.yml
    }}

    \image{images/tutorial/hello-world-trigger-job.png}
}
